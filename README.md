# MIPS32 Xilinx Processor Block
This repository contains the Verilog code for my MIPS32 processor on FPGA. I wrote it for the Computer Architecture course ECE 369 at the University of arizona. It is the base for the multi-core processor I designed for the ECE 369 processor-on-FPGA competition. This implementation showcases a pipelined architecture for a subset of the MIPS32 instruction set. It can be used as a basis for a full MIPS32 processor implementation by adding missing features like a Floating Point Unit (FPU), cache levels, and exception handling.

## Hardware
This processor block was written for the [Digilent Nexys 4 board](https://digilent.com/reference/programmable-logic/nexys-4/start) containing the [Xilinx Artix-7 FPGA](https://www.xilinx.com/products/silicon-devices/fpga/artix-7.html), but it can be easily adapted to any other board and FPGA by modifying the contraint file [Two4DigitDisplay.xdc](constrs_1/new/Two4DigitDisplay.xdc). At the FPGA level, the block's inputs are the board oscillator pin as a clock and a push-button pin as a user reset button. The block's outputs are the pins for the 8-digit 7-segment display.

## File Structure
The main content is the [Verilog source files](sources_1/new) in which the processor hardware description code is written. The repository also contains the [simulation testbench](sim_1/new/processor_tb.v) and the [contraint file](constrs_1/new/Two4DigitDisplay.xdc) for the FPGA board. Some test programs are included with their assembly codes, instruction memories, data memories, and expected outputs.

## Setup
The Verilog code was sucessfully sythesized and tested with the Artix-7 FPGA using the [Xilinx Vivado IDE](https://www.xilinx.com/products/design-tools/vivado.html). I would recommend creating a new project with the XC7A100T-1CSG324C FPGA target and copying the files into its source directory. [The top level file](sources_1/new/top_level.v) should be set as the top level block before running simulations or synthesis.

## Top Level Structure
The [top level file](sources_1/new/top_level.v) connects the high-level blocks. The processor's output, which is the last written register value, is passed to the [8-digit 7-segment display driver block](sources_1/new/Two4DigitDisplay.v) which uses the [7-segment display driver block](sources_1/new/SevenSegment.v). The processor is driven by the board oscillator input passed through a [clock divider](sources_1/new/ClkDiv.v). The divider ensures the processor is slow enough for the user to see the written register values change on the display.

## Pipeline Structure
![Processor pipeline](/schematic.png)
The [processor pipeline](sources_1/new/Processor.v) is split into five stages as shown in the schematic above. Instruction Fetch (IF), Instruction Decode (ID), Execution (EX), Memory (MEM), and Write Back (WB). The stages are separated by [pipeline registers](sources_1/new/PipeReg.v) that buffer the output of each stage for the next clock cycle. The [IF unit](sources_1/new/InstructionFetchUnit.v) handles the [program counter](sources_1/new/ProgramCounter.v) and reads from the [instruction memory](sources_1/new/InstructionMemory.v). The [ID unit](sources_1/new/InstructionDecodeUnit.v) decode the instruction into the right register values from its [register file](sources_1/new/RegisterFile.v) and control signals using the [control unit](sources_1/new/ControlUnit.v) and [compare unit](sources_1/new/ComapreUnit.v). The [Ex unit](sources_1/new/ExecutionUnit.v) makes requested ahrithmetic operations using the [Ahrithmetic and Logic Unit (ALU)](sources_1/new/ALU32Bit.v) and selects which values and control signals need to be passed further. The [MEM unit](sources_1/new/MemoryUnit.v) reads from and writes to its [data memory](sources_1/new/DataMemory.v). The [WB unit](sources_1/new/WriteBackUnit.v) writes back values to the register file used by the ID unit.

## Program Structure
The processor is designed to run a single application starting at address 0. The instruction and data memories are separate in the pipeline. Each of them is preloaded using its memory file. Both the instruction and data memories are assembled from the program's assembly file. The output shown on the simulation testbench waveform or the FPGA board's 8-digital 7-segment display is the new value of the register written in the last clock cycle. 
