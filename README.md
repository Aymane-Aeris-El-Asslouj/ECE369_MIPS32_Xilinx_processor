# MIPS32 Xilinx Processor Block
This repository contains the Verilog code for my MIPS32 processor on FPGA. I wrote it for the Computer Architecture course ECE 369 at the University of arizona. It is the base for [the multi-core processor](https://github.com/Aymane-Aeris-El-Asslouj/ECE369_competition_MIPS32_Xilinx_multicore_processor) I designed for the ECE 369 processor-on-FPGA competition and is able to run [my implementation of the SAD algorithm](https://github.com/Aymane-Aeris-El-Asslouj/ECE369_MIPS32_SAD_Assembly_code) in assembly. This implementation showcases a pipelined architecture for a subset of the MIPS32 instruction set. It can be used as a basis for a full MIPS32 processor implementation by adding missing features like a Floating Point Unit (FPU), cache levels, and exception handling.

## Hardware
This processor block was written for the [Digilent Nexys 4 board](https://digilent.com/reference/programmable-logic/nexys-4/start) containing the [Xilinx Artix-7 FPGA](https://www.xilinx.com/products/silicon-devices/fpga/artix-7.html), but it can be easily adapted to any other board and FPGA by modifying the contraint file [Two4DigitDisplay.xdc](constraints/Two4DigitDisplay.xdc). At the FPGA level, the block's inputs are the board oscillator pin as a clock and a push-button pin as a user reset button. The block's outputs are the pins for the 8-digit 7-segment display.

## File Structure
The main content is the [Verilog source files](sources) in which the processor hardware description code is written. The repository also contains the [simulation testbench](test_bench/processor_tb.v) and the [contraint file](constraints/Two4DigitDisplay.xdc) for the FPGA board. Three test programs are included with their assembly codes, instruction memories, data memories, and expected outputs.

## Setup
The Verilog code was sucessfully sythesized and tested with the Artix-7 FPGA using the [Xilinx Vivado IDE](https://www.xilinx.com/products/design-tools/vivado.html). I would recommend creating a new project with the XC7A100T-1CSG324C FPGA target and copying the files into its source directory. [The top level file](sources/top_level.v) should be set as the top level block before running simulations or synthesis.

## Top Level Structure
The [top level file](sources/top_level.v) connects the high-level blocks. The processor's output, which is the last written register value, is passed to the [8-digit 7-segment display driver block](sources/Two4DigitDisplay.v) which uses the [7-segment display driver block](sources/SevenSegment.v). The processor is driven by the board oscillator input passed through a [clock divider](sources/ClkDiv.v). The divider ensures the processor is slow enough for the user to see the written register values change on the display.

## Pipeline Structure
![Processor pipeline](/schematic.png)
The [processor pipeline](sources/Processor.v) is split into five stages as shown in the schematic above. Instruction Fetch (IF), Instruction Decode (ID), Execution (EX), Memory (MEM), and Write Back (WB). The stages are separated by [pipeline registers](sources/PipeReg.v) that buffer the output of each stage for the next clock cycle. The [IF unit](sources/InstructionFetchUnit.v) handles the [program counter](sources/ProgramCounter.v) and reads from the [instruction memory](sources/InstructionMemory.v). The [ID unit](sources/InstructionDecodeUnit.v) decode the instruction into the right register values from its [register file](sources/RegisterFile.v) and control signals using the [control unit](sources/ControlUnit.v) and [compare unit](sources/ComapreUnit.v). The [Ex unit](sources/ExecutionUnit.v) makes requested ahrithmetic operations using the [Ahrithmetic and Logic Unit (ALU)](sources/ALU32Bit.v) and selects which values and control signals need to be passed further. The [MEM unit](sources/MemoryUnit.v) reads from and writes to its [data memory](sources/DataMemory.v). The [WB unit](sources/WriteBackUnit.v) writes back values to the register file used by the ID unit.

## Program Structure
The processor is designed to run a single application starting at address 0. The instruction and data memories are separate in the pipeline. Each of them is preloaded using its memory file (instruction_memory.mem and data_memory.mem). Both the instruction and data memories are assembled from the program's assembly file (instruction.s). The output shown on the simulation testbench waveform or the FPGA board's 8-digital 7-segment display is the new value of the register written in the last clock cycle. Expected outputs are shown in output.txt files.
